/*
* DO NOT EDIT
* this class has been generated by fr.inria.hocl.core.hoclc2j version0.1->0.2
* on Mon Sep 26 15:18:07 CEST 2011
*/

package fr.inria.hocl.tests.sortPivot;
import java.io.*;
import fr.inria.hocl.core.hocli.*;
import fr.inria.hocl.core.hocli.workflow.*;
import fr.inria.hocl.workflow.utils.*;
import fr.inria.hocl.core.hoclc2j.Hoclc2j;
import java.rmi.Naming;
import java.rmi.RMISecurityManager;
import java.net.InetAddress;
import java.net.URL;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
public class RunSortPivot_gen {

private static Logger log = null;
private static FileHandler fileHTML;
private static Formatter formatterHTML;
public static boolean awake=true;
	public static Molecule addElement(String line, Solution sol) throws Exception{
		Molecule mol = new Molecule();
					if (line.equals("put") || line.equals("p")) {
						mol = sol.addElement();
						//sol.setNonInert();
						//sol.reduce();
					}

		return mol;
	}

	public static boolean deleteDir(File dir) {
		if (dir.isDirectory()) {
			String[] children = dir.list();

			for (int i=0; i<children.length; i++) {

				boolean success = deleteDir(new File(dir, children[i]));

				if (!success) {

					return false;

				}

			}

		}

		return dir.delete();
	}

	private static void setupLogger(){
		log = Logger.getLogger(fr.inria.hocl.workflow.utils.IConstants.LOG_NAME);
		log.setLevel(Level.INFO);
		log.setUseParentHandlers(false);
		try{
		FileHandler fileHTML = new FileHandler(fr.inria.hocl.workflow.utils.IConstants.HTML_LOG_NAME);
		formatterHTML = new Log_HtmlFormatter();
		fileHTML.setFormatter(formatterHTML);
		log.addHandler(fileHTML);
		log.getHandlers()[0].setLevel(Level.INFO);
		} catch(IOException e){
			log.severe("Impossible to configure HTML logger. ERROR: "+e.getMessage());
		}
	}
	public static void main(String args[]) throws Exception{
		boolean quitshell = false;
		Hocli.init(args);
		Solution sol = new SortPivot_gen();
		setupLogger();
		System.out.println("HOCL shell");
		System.out.println("Copyright INRIA, 2009");
		while (!quitshell) {
			try{
				System.out.print("hocl> ");
				String line = new BufferedReader(new InputStreamReader(System.in)).readLine();
				if( line == null ) {
					quitshell = true;
					System.out.println();
				} else if (line.startsWith("put")||line.startsWith("p")||line.startsWith("PUT")||line.startsWith("P")){
					sol.addMolecule(addElement(line,sol));
				}

				else if (line.startsWith("get")||line.startsWith("g")||line.startsWith("GET")||line.startsWith("G")){
					if (line.equals("get") || line.equals("g")) {
						// First scanning for display
						SimpleIterator<Atom> it = sol.newIterator();
						Atom atom = null;
						int cpt_at = 1;
						while( it.hasNext() ) {
							atom = it.next();
							System.out.println( cpt_at + ": " + atom );
							cpt_at++;
						}
						System.out.println( cpt_at + ": " + it.next() );
						// Second scanning for removing itself
						System.out.println("Enter the number of the element to be removed:");
						String input = new BufferedReader( new InputStreamReader( System.in ) ).readLine();
						int atomNb = ( new Integer( input ) ).intValue();
						it = sol.newIterator();
						cpt_at = 1;
						while( cpt_at <= atomNb ) {
							atom = it.next();
							cpt_at++;
						}
					sol.removeAtomFromContainer(atom);
					}

				}
				else{

					if (line.equals("quit") || line.equals("q"))
						quitshell=true;

					else if (line.equals("run") || line.equals("r")){
							sol.setNonInert();
							sol.reduce();
					}

					else if (line.equals("startEngine") || line.equals("e")){
						while(true){
								sol.setNonInert();
								sol.reduce();
						}
					}

					else if (line.equals("debug") || line.equals("d")) {
						System.out.print("Which level (0-9)? ");
						line = new BufferedReader(new InputStreamReader(System.in)).readLine();
						Hocli.setVerboseLevel(Integer.decode(line));
						System.out.println("Debug level set to " + line);
						}

					else if (line.equals("strategy") || line.equals("s")) {
						while( true ) {
							System.out.print("Which strategy (FR / UFR / RAND / KSS) ? ");
							line = new BufferedReader(new InputStreamReader(System.in)).readLine();
							if( line == null || line.isEmpty() ) {
								System.out.println( "You must enter a strategy name!" );
								continue;
							}
							line = line.trim();
							if( line.equalsIgnoreCase( "fr" ) )
								break;
							if( line.equalsIgnoreCase( "ufr" ) )
								break;
							if( line.equalsIgnoreCase( "rand" ) )
								break;
							if( line.equalsIgnoreCase( "kss" ) )
								break;
							System.out.println( line + " is not a valid strategy!" );
						}
						Hocli.setStrategy(line);
						System.out.println("Strategy set to " + line);
						}

					else if (line.equals("display") || line.equals("dp")) {
						sol.printsol();
					}

					else if (line.equals("check") || line.equals("cht")) {
						System.out.println("All the supported types of elements:\n");
						System.out.println(((SortPivot_gen) sol).displayTypes());
					}
					else if (line.equals("help") || line.equals("h")) {
						System.out.println("(q) quit - exit the HOCL shell");
						System.out.println("(r) run - run the HOCL program");
						System.out.println("(d) debug - set debug level");
						System.out.println("(s) strategy - select strategy");
						System.out.println("(p) put - add a molecule to the multi-set");
						System.out.println("(g) get - get a molecule from the multi-set");
						System.out.println("(dp) display - display solution");
						System.out.println("(cht) check - check all the supported types of elements");
						System.out.println("(e) startEngine - startup the hocl engine");
					}
					 else if (line.equals("newrule") || line.equals("nr")){
						System.out.println("Please give your rule name:\n");
						String newRuleName = new BufferedReader(new InputStreamReader(System.in)).readLine();
						System.out.println("Please give your rule definition:\n");
						String newRuleDef = new BufferedReader(new InputStreamReader(System.in)).readLine();
						String newProgram = 
							"let "+newRuleName+ " =\n"+
							newRuleDef+
							"\nin\n"+
							"<"+newRuleName+">\n";
						try{
							File ruledir = new File("./rules/");

							if(!(new File("./rules/").isDirectory())){
								ruledir.mkdir();
							}
							FileOutputStream genFile = new FileOutputStream("./rules/./sortPivot.hocl");
							DataOutputStream dataFile = new DataOutputStream(genFile);
							dataFile.writeBytes(newProgram);
							dataFile.close();
							try{
								String inputFiles[] = new String[1];
								inputFiles[0] = "./rules/./sortPivot.hocl";
								Hoclc2j compiler = new Hoclc2j(inputFiles);
								compiler.run();
								String ruleClassName = Character.toUpperCase(newRuleName.charAt(0)) + newRuleName.substring(1);
								File file = new File("./rules/"+ruleClassName+".java");
								File dir = new File("./");
								if(file.renameTo(new File(dir, file.getName()))){
									if(deleteDir(ruledir)){
										try{
											Runtime   r   =   Runtime.getRuntime();
											String compile = "javac -cp ../../../bin -d ../../../bin "+ruleClassName+".java";
											r.exec(compile);
											((SortPivot_gen)sol).addType(ruleClassName);
											System.out.println("The new rule have been created!\n");
										}catch(Exception e){
											System.out.println("You might have the following error(s) during compiling new rules:\n" +e);
										}
									}
								}
							}catch(Exception e){
								System.out.println("You might have the following error(s) during your definition of rules:\n" +e);
							}
						}catch(Exception e){
							System.out.println("Exception during creating new HOCL files:\n" +e);
						}
					}
					else{
						System.out.println("Command '"+line+"' does not exist.\nInput 'help' (h) to check all the commands.");					}
				}

			}
			catch (IOException e) {
				//e.printStackTrace();
				System.out.println("e");
			}
		}
	}
} // class RunSortPivot_gen
